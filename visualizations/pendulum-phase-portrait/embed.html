<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pendulum Phase Portrait</title>
  <style>
    :root { --panel: rgba(31,41,55,.35); }
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;margin:0;background:#111827;color:#f3f4f6;display:flex;flex-direction:column;align-items:center;min-height:100vh;overflow:hidden}
    #wrap{position:relative;display:inline-block;box-shadow:0 0 20px rgba(0,191,255,.25);border:1px solid #374151;border-radius:.5rem}
    canvas{background:#000;cursor:grab;display:block;border-radius:.5rem}
    canvas:active{cursor:grabbing}
    .controls{position:absolute;left:50%;bottom:.5rem;transform:translateX(-50%);display:flex;flex-direction:row;gap:.5rem;align-items:center;justify-content:center;background:var(--panel);backdrop-filter:blur(4px);padding:.25rem .5rem;border-radius:.5rem;pointer-events:none}
    .controls>*{pointer-events:auto}
    .btn{background:#374151;color:#f3f4f6;padding:.25rem .5rem;border:0;border-radius:.375rem;font-weight:600;font-size:.8rem;cursor:pointer;}
    .btn:hover{background:#4b5563}
    .range{width:100px;height:6px;background:#4b5563;border-radius:3px;outline:0;-webkit-appearance:none;appearance:none}
    .range::-webkit-slider-thumb{width:14px;height:14px;background:#60a5fa;border-radius:50%;box-shadow:0 0 4px #60a5fa;-webkit-appearance:none;appearance:none}
    .range::-moz-range-thumb{width:14px;height:14px;background:#60a5fa;border-radius:50%;box-shadow:0 0 4px #60a5fa}
    .title{margin:1rem 0;text-align:center}
    .title h1{font-size:2rem;font-weight:800;letter-spacing:-.02em;margin:.25rem 0}
    .title p{color:#9ca3af;margin:0 auto;max-width:640px}
  </style>
</head>
<body>
  <div class="title">
    <h1>Pendulum Phase Portrait</h1>
    <p>Click to add a trajectory. Drag to pan. Scroll to zoom.</p>
  </div>

  <div id="wrap">
    <canvas id="phaseCanvas"></canvas>
    <div id="equation" style="position:absolute;left:.5rem;top:.5rem;background:transparent;padding:.4rem .6rem;border-radius:.5rem;font-size:.9rem;line-height:1.2;pointer-events:none">
      <div style="font-weight:700;margin-bottom:.25rem">Damped pendulum (phase form)</div>
      <div style="white-space:pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;">
        θ' = ω
        ω' = - (g/L)·sin(θ) - γ·ω
      </div>
    </div>
    <div class="controls">
      <button id="startStopBtn" class="btn">Start</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="clearBtn" class="btn">Clear</button>
      <label class="text-xs" style="opacity:.85; color: #f3f4f6; font-size: .8rem;">Damping: <span id="dampingValue">0.10</span></label>
      <input id="dampingSlider" class="range" type="range" min="-0.5" max="0.5" step="0.01" value="0.1" />
    </div>
  </div>

  <script>
  // ---------- Elements & State ----------
  const $=id=>document.getElementById(id);
  const canvas=$('phaseCanvas'),ctx=canvas.getContext('2d');
  const startStopBtn=$('startStopBtn'),resetBtn=$('resetBtn'),clearBtn=$('clearBtn');
  const dampingSlider=$('dampingSlider'),dampingValue=$('dampingValue');

  let isAnimating=false,isPanning=false,lastX=0,lastY=0,clickTO=null,spawnC=0,needsFullRedraw=true;
  const SPAWN=60,params={gL:1,damping:.1,dt:.01},view={tMin:-2*Math.PI,tMax:2*Math.PI,oMin:-3,oMax:3,sX:1,sY:1};
  let trajectories=[];

  // ---------- Coordinate Maps ----------
  const mapTo=(th,om)=>({x:(th-view.tMin)*view.sX,y:canvas.height-(om-view.oMin)*view.sY});
  const mapFrom=(x,y)=>({th:x/view.sX+view.tMin,om:(canvas.height-y)/view.sY+view.oMin});

  // ---------- Trajectory ----------
  class Traj{
    constructor(th,om,m=500){ this.h=[{th,om}], this.i=0, this.m=m, this.c=`hsl(${Math.random()*360},90%,65%)`; }
    step(){ let {th,om}=this.h[this.h.length-1]; om+=(-params.gL*Math.sin(th)-params.damping*om)*params.dt; th+=om*params.dt; this.h.push({th,om}); if(this.h.length>this.m){ this.h.shift(); this.i=Math.max(0,this.i-1);} }
    drawFull(){
      if(this.h.length<2) return; ctx.beginPath(); ctx.strokeStyle=this.c; ctx.lineWidth=1.3; ctx.globalAlpha=.9;
      let s=0; for(let k=s+1;k<this.h.length;k++){ const a=mapTo(this.h[k-1].th,this.h[k-1].om), b=mapTo(this.h[k].th,this.h[k].om); if(Math.abs(a.x-b.x)<canvas.width*.9){ ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);} }
      ctx.stroke(); ctx.globalAlpha=1;
    }
    drawSegment(prev,curr){
      const a=mapTo(prev.th,prev.om), b=mapTo(curr.th,curr.om); ctx.beginPath(); ctx.strokeStyle=this.c; ctx.lineWidth=1.3; ctx.globalAlpha=.95; if(Math.abs(a.x-b.x)<canvas.width*.9){ ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);} ctx.stroke(); ctx.globalAlpha=1;
    }
  }

  // ---------- Rendering ----------
  function drawAxes(){
    ctx.strokeStyle='#4b5563'; ctx.lineWidth=1;
    const y0=mapTo(0,0).y; if(y0>=0&&y0<=canvas.height){ ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(canvas.width,y0); ctx.stroke(); }
    for(let th=Math.ceil(view.tMin/(2*Math.PI))*(2*Math.PI); th<=view.tMax; th+=2*Math.PI){ const x=mapTo(th,0).x; if(x>=0&&x<=canvas.width){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }}
    ctx.fillStyle='#9ca3af'; ctx.font='12px system-ui, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.fillText('θ', Math.min(canvas.width-16, canvas.width-20), Math.min(canvas.height-16, y0+5));
    const x0=mapTo(0,0).x; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText('ω', Math.min(canvas.width-16, x0+5), 12);
  }

  function drawField(){
    const nx=40, ny=24;
    const dxpx = canvas.width / nx, dypx = canvas.height / ny;
    const L = 0.35 * Math.min(dxpx, dypx);
    ctx.save(); ctx.strokeStyle='rgba(200,200,200,.6)'; ctx.lineWidth=1;
    for(let i=0;i<=nx;i++){
      for(let j=0;j<=ny;j++){
        const th = view.tMin + (i/nx)*(view.tMax-view.tMin);
        const om = view.oMin + (j/ny)*(view.oMax-view.oMin);
        let v1 = om; let v2 = -params.gL*Math.sin(th) - params.damping*om;
        const len = Math.hypot(v1, v2) || 1; v1/=len; v2/=len;
        const p = mapTo(th, om);
        const a = {x: p.x - L*v1, y: p.y + L*v2};
        const b = {x: p.x + L*v1, y: p.y - L*v2};
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
    }
    ctx.restore();
  }

  function setup(){
    const size=Math.min(innerWidth*.92,720); canvas.width=size; canvas.height=size*.72;
    view.sX=canvas.width/(view.tMax-view.tMin); view.sY=canvas.height/(view.oMax-view.oMin);
    needsFullRedraw=true;
  }

  function init(){
    trajectories=[];
    for(let i=-6;i<=6;i++) for(let j=-2;j<=2;j++){ if(i||j){ trajectories.push(new Traj(i*Math.PI/2, j*1.5)); } }
  }

  function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    drawAxes(); 
    drawField();
    trajectories.forEach(t=>t.drawFull());
  }

  function zoom(f){
    const cx=(view.tMin+view.tMax)/2, cy=(view.oMin+view.oMax)/2;
    const rt=(view.tMax-view.tMin)*f, ro=(view.oMax-view.oMin)*f;
    view.tMin=cx-rt/2; view.tMax=cx+rt/2; view.oMin=cy-ro/2; view.oMax=cy+ro/2;
    setup();
  }

  function animate(){
    if(isAnimating){
      if(needsFullRedraw){ redraw(); needsFullRedraw=false; }
      if(++spawnC>=SPAWN){ const r=mapFrom(Math.random()*canvas.width,Math.random()*canvas.height); trajectories.push(new Traj(r.th,r.om)); spawnC=0; }
      for(const t of trajectories){
        const prev = t.h[t.i];
        t.i<t.h.length-1 ? t.i++ : (t.step(), t.i++);
        const curr = t.h[t.i]; if(prev && curr){ t.drawSegment(prev, curr); }
      }
    } else if(needsFullRedraw){ redraw(); needsFullRedraw=false; }
    requestAnimationFrame(animate);
  }
  
  // ---------- Events ----------
  startStopBtn.onclick=()=>{ isAnimating=!isAnimating; startStopBtn.textContent=isAnimating?'Stop':'Start'; if(!isAnimating){ needsFullRedraw=true; redraw(); } };
  resetBtn.onclick=()=>{ Object.assign(view,{tMin:-2*Math.PI,tMax:2*Math.PI,oMin:-3,oMax:3}); setup(); init(); isAnimating=false; startStopBtn.textContent='Start'; needsFullRedraw=true; redraw(); };
  clearBtn.onclick=()=>{ init(); needsFullRedraw=true; };
  dampingSlider.oninput=e=>{ params.damping=+e.target.value; dampingValue.textContent=params.damping.toFixed(2); needsFullRedraw=true; };

  canvas.onwheel = e => {
    e.preventDefault();
    const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;
    zoom(zoomFactor);
    needsFullRedraw = true;
  };
  canvas.onmousedown=e=>{ isPanning=true; lastX=e.clientX; lastY=e.clientY; clickTO=setTimeout(()=>clickTO=null,200); };
  canvas.onmouseup=e=>{ isPanning=false; if(clickTO){ clearTimeout(clickTO); const r=canvas.getBoundingClientRect(); const {th,om}=mapFrom(e.clientX-r.left, e.clientY-r.top); trajectories.push(new Traj(th,om)); } };
  canvas.onmouseleave=()=>{ isPanning=false; };
  canvas.onmousemove=e=>{ if(!isPanning) return; if(clickTO){ clearTimeout(clickTO); clickTO=null; } const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; view.tMin-=dx/view.sX; view.tMax-=dx/view.sX; view.oMin+=dy/view.sY; view.oMax+=dy/view.sY; setup(); needsFullRedraw=true; };
  onresize=()=>{ setup(); needsFullRedraw=true; };

  // ---------- Boot ----------
  setup(); init(); redraw();
  requestAnimationFrame(animate);
  </script>
</body>
</html>
