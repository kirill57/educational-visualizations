<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pendulum Lab</title>
    <style>
        :root { --panel: rgba(15, 23, 42, 0.78); }
        * { box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #1e293b 0%, #0f172a 55%, #020617 100%); color: #f8fafc; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow-x: hidden; }
        .title { margin: 1.2rem 0 0.8rem; text-align: center; padding: 0 1rem; }
        .title h1 { font-size: 2.2rem; font-weight: 800; letter-spacing: -0.03em; margin: 0.3rem 0; text-shadow: 0 8px 20px rgba(59, 130, 246, 0.22); }
        .title p { color: rgba(226, 232, 240, 0.72); margin: 0 auto; max-width: 720px; font-size: 0.95rem; }
        #wrap { position: relative; width: min(1024px, 94vw); border-radius: 0.9rem; border: 1px solid rgba(148, 163, 184, 0.18); box-shadow: 0 18px 40px rgba(15, 23, 42, 0.55); background: rgba(15, 23, 42, 0.4); backdrop-filter: blur(8px); padding: 1.1rem 1.1rem 4.6rem; margin-bottom: 2rem; }
        .layout { display: flex; gap: 1rem; }
        .pane { position: relative; flex: 1; border-radius: 0.75rem; overflow: hidden; border: 1px solid rgba(148, 163, 184, 0.15); background: rgba(15, 23, 42, 0.85); box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.15); }
        canvas { width: 100%; height: 100%; display: block; }
        .pane-label { position: absolute; left: 1rem; top: 0.9rem; padding: 0.25rem 0.75rem; border-radius: 999px; background: rgba(30, 41, 59, 0.75); font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(191, 219, 254, 0.88); backdrop-filter: blur(4px); z-index: 1; }
        #stats { position: absolute; left: 1rem; bottom: 1rem; background: transparent; padding: 0.55rem 0.85rem; border-radius: 0.6rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 0.82rem; line-height: 1.6; color: rgba(226, 232, 240, 0.88); border: none; z-index: 1;}
        .controls { position: absolute; left: 50%; bottom: 1.2rem; transform: translateX(-50%); display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; justify-content: center; background: transparent; padding: 0.6rem 0.9rem; border-radius: 0.7rem; }
        .controls > * { pointer-events: auto; }
        .btn { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #f1f5f9; padding: 0.4rem 0.9rem; border: 0; border-radius: 0.5rem; font-weight: 600; font-size: 0.82rem; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease; box-shadow: 0 10px 18px rgba(37, 99, 235, 0.28); }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 14px 22px rgba(37, 99, 235, 0.38); }
        .btn:active { transform: translateY(1px); }
        .param-group { display: flex; flex-direction: column; gap: 0.28rem; min-width: 140px; }
        .param-label { font-size: 0.7rem; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(226, 232, 240, 0.75); }
        .range { width: 100%; height: 6px; background: rgba(148, 163, 184, 0.28); border-radius: 3px; outline: none; -webkit-appearance: none; appearance: none; cursor: pointer; }
        .range::-webkit-slider-thumb { width: 16px; height: 16px; border-radius: 50%; background: #38bdf8; border: none; box-shadow: 0 0 10px rgba(56, 189, 248, 0.65); -webkit-appearance: none; }
        .range::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #38bdf8; border: none; box-shadow: 0 0 10px rgba(56, 189, 248, 0.65); }
        @media (max-width: 840px) {
            #wrap { padding-bottom: 9rem; }
            .layout { flex-direction: column; }
            .param-group { min-width: 130px; }
            .controls { width: calc(100% - 2.2rem); }
        }
    </style>
</head>
<body>
    <div class="title">
        <h1>Pendulum Lab</h1>
        <p>Adjust the initial angle, angular velocity, length, gravity, and damping. The left panel shows the pendulum's motion, while the right panel traces its state through phase space.</p>
    </div>
    <div id="wrap">
        <div class="layout">
            <div class="pane" id="pendulumPane">
                <canvas id="pendulumCanvas"></canvas>
                <div class="pane-label">Pendulum</div>
                <div id="stats"></div>
            </div>
            <div class="pane" id="phasePane">
                <canvas id="phaseCanvas"></canvas>
                <div class="pane-label">Phase Portrait</div>
            </div>
        </div>
        <div class="controls">
            <button id="startStopBtn" class="btn">Start</button>
            <button id="resetBtn" class="btn">Reset</button>
            <div class="param-group">
                <label class="param-label">Angle θ₀ (rad): <span id="theta0Value">1.50</span></label>
                <input id="theta0Slider" class="range" type="range" min="-3.14" max="3.14" step="0.01" value="1.5" />
            </div>
            <div class="param-group">
                <label class="param-label">Ang. Vel. ω₀ (rad/s): <span id="omega0Value">0.00</span></label>
                <input id="omega0Slider" class="range" type="range" min="-5" max="5" step="0.01" value="0" />
            </div>
            <div class="param-group">
                <label class="param-label">Length L (m): <span id="lengthValue">1.00</span></label>
                <input id="lengthSlider" class="range" type="range" min="0.2" max="2" step="0.01" value="1" />
            </div>
            <div class="param-group">
                <label class="param-label">Gravity g (m/s²): <span id="gravityValue">9.81</span></label>
                <input id="gravitySlider" class="range" type="range" min="1" max="25" step="0.01" value="9.81" />
            </div>
             <div class="param-group">
                <label class="param-label">Damping b: <span id="dampingValue">0.00</span></label>
                <input id="dampingSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" />
            </div>
        </div>
    </div>

    <script>
    // --- Element Selection ---
    const $ = id => document.getElementById(id);
    const pendulumCanvas = $('pendulumCanvas');
    const phaseCanvas = $('phaseCanvas');
    const pendulumCtx = pendulumCanvas.getContext('2d');
    const phaseCtx = phaseCanvas.getContext('2d');

    const startStopBtn = $('startStopBtn');
    const resetBtn = $('resetBtn');
    const theta0Slider = $('theta0Slider');
    const omega0Slider = $('omega0Slider');
    const lengthSlider = $('lengthSlider');
    const gravitySlider = $('gravitySlider');
    const dampingSlider = $('dampingSlider');
    const theta0Value = $('theta0Value');
    const omega0Value = $('omega0Value');
    const lengthValue = $('lengthValue');
    const gravityValue = $('gravityValue');
    const dampingValue = $('dampingValue');
    const statsEl = $('stats');
    
    // --- Global State ---
    const params = {
        L: parseFloat(lengthSlider.value),
        g: parseFloat(gravitySlider.value),
        theta0: parseFloat(theta0Slider.value),
        omega0: parseFloat(omega0Slider.value),
        b: parseFloat(dampingSlider.value)
    };
    const state = { theta: params.theta0, omega: params.omega0, t: 0, m: 1 }; // mass is 1 kg
    let running = false;
    let lastFrameTime = null;
    let accumulator = 0;
    const baseStep = 0.004; // Fixed time step for physics
    const history = [];
    let lastSampleTime = 0;
    const sampleInterval = 0.01;
    const maxHistory = 2200;
    
    // --- Canvas and Physics Setup ---
    function handleResize() {
        const wrapBounds = $('wrap').getBoundingClientRect();
        const padding = 1.1 * parseFloat(getComputedStyle(document.documentElement).fontSize);
        const contentWidth = wrapBounds.width - (padding * 2);
        const isColumnLayout = window.innerWidth < 840;

        let pendulumW, pendulumH, phaseW, phaseH;

        if (isColumnLayout) {
            pendulumW = phaseW = contentWidth;
            pendulumH = phaseH = contentWidth * 0.8;
        } else {
            pendulumW = contentWidth * 0.5 - 5;
            phaseW = contentWidth * 0.5 - 5;
            pendulumH = phaseH = contentWidth * 0.45;
        }

        const setupSingleCanvas = (canvas, ctx, w, h) => {
            const dpr = window.devicePixelRatio || 1;
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h}px`;
            canvas.width = Math.round(w * dpr);
            canvas.height = Math.round(h * dpr);
            ctx.scale(dpr, dpr);
        };
        
        setupSingleCanvas(pendulumCanvas, pendulumCtx, pendulumW, pendulumH);
        setupSingleCanvas(phaseCanvas, phaseCtx, phaseW, phaseH);
    }
    
    // --- RK4 Integrator for accurate physics ---
    function rk4Step(dt) {
        const y = { theta: state.theta, omega: state.omega };

        const f = (y_in) => {
            return {
                d_theta: y_in.omega,
                d_omega: -(params.g / params.L) * Math.sin(y_in.theta) - params.b * y_in.omega
            };
        };

        const k1 = f(y);
        const k2 = f({ theta: y.theta + 0.5 * dt * k1.d_theta, omega: y.omega + 0.5 * dt * k1.d_omega });
        const k3 = f({ theta: y.theta + 0.5 * dt * k2.d_theta, omega: y.omega + 0.5 * dt * k2.d_omega });
        const k4 = f({ theta: y.theta + dt * k3.d_theta, omega: y.omega + dt * k3.d_omega });

        state.theta += dt / 6 * (k1.d_theta + 2 * k2.d_theta + 2 * k3.d_theta + k4.d_theta);
        state.omega += dt / 6 * (k1.d_omega + 2 * k2.d_omega + 2 * k3.d_omega + k4.d_omega);
        state.t += dt;
    }

    function advance(frameDt) {
        const clampedDt = Math.min(frameDt, 0.06); // Prevent instability
        accumulator += clampedDt;
        while (accumulator >= baseStep) {
            rk4Step(baseStep);
            recordHistory();
            accumulator -= baseStep;
        }
    }
    
    // --- State and History Management ---
    function recordHistory() {
        if (state.t - lastSampleTime < sampleInterval) return;
        lastSampleTime = state.t;
        history.push({ theta: state.theta, omega: state.omega });
        if (history.length > maxHistory) {
            history.splice(0, history.length - maxHistory);
        }
    }

    function resetHistory() { history.length = 0; lastSampleTime = 0; }

    function resetState() {
        state.theta = params.theta0;
        state.omega = params.omega0;
        state.t = 0;
        accumulator = 0;
        resetHistory();
        recordHistory();
    }
    
    // --- Drawing Functions ---
    function drawPendulum() {
        const ctx = pendulumCtx;
        const w = pendulumCanvas.clientWidth;
        const h = pendulumCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);
        
        const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
        bgGradient.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
        bgGradient.addColorStop(1, 'rgba(2, 6, 23, 0.95)');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, w, h);

        const pivotX = w / 2;
        const pivotY = h * 0.2;
        const pixelsPerMeter = Math.min(w * 0.4, h * 0.7) / params.L;
        const bobRadius = 18;

        const bobX = pivotX + pixelsPerMeter * params.L * Math.sin(state.theta);
        const bobY = pivotY + pixelsPerMeter * params.L * Math.cos(state.theta);

        // Ceiling
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(0, pivotY - 15, w, 15);
        ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
        ctx.beginPath(); ctx.moveTo(0, pivotY); ctx.lineTo(w, pivotY); ctx.stroke();

        // Rod
        ctx.strokeStyle = 'rgba(148, 163, 184, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(pivotX, pivotY);
        ctx.lineTo(bobX, bobY);
        ctx.stroke();

        // Pivot
        ctx.fillStyle = '#94a3b8';
        ctx.beginPath(); ctx.arc(pivotX, pivotY, 6, 0, Math.PI * 2); ctx.fill();

        // Bob
        const bobGradient = ctx.createRadialGradient(bobX - 5, bobY - 5, 2, bobX, bobY, bobRadius);
        bobGradient.addColorStop(0, '#f1f5f9');
        bobGradient.addColorStop(1, '#94a3b8');
        ctx.fillStyle = bobGradient;
        ctx.beginPath(); ctx.arc(bobX, bobY, bobRadius, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(15, 23, 42, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawPhase() {
        const ctx = phaseCtx;
        const w = phaseCanvas.clientWidth;
        const h = phaseCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        ctx.fillStyle = 'rgba(2, 6, 23, 0.96)';
        ctx.fillRect(0, 0, w, h);

        const margin = 36;
        const centerX = w / 2;
        const centerY = h / 2;

        const E_critical = 2 * state.m * params.g * params.L;
        const current_E = computeEnergy();
        const isRotating = current_E > E_critical && Math.abs(state.omega) > 0.1;
        const theta_center = isRotating ? state.theta : 0;
        const wrapAngle = angle => ((angle + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI;

        // BUGFIX 1: Make omegaRange dynamic for better visualization of damped motion.
        let maxAbsOmega = 0;
        if (history.length > 0) {
            maxAbsOmega = history.reduce((max, p) => Math.max(max, Math.abs(p.omega)), 0);
        }
        maxAbsOmega = Math.max(maxAbsOmega, Math.abs(state.omega));
        const omegaRange = Math.max(4, maxAbsOmega * 1.2);

        const thetaRange = Math.PI;
        const scaleX = (w / 2 - margin) / thetaRange;
        const scaleY = (h / 2 - margin) / omegaRange;

        // Axes
        ctx.strokeStyle = 'rgba(96, 165, 250, 0.75)';
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(margin, centerY); ctx.lineTo(w - margin, centerY); // Theta-axis
        ctx.moveTo(centerX, margin); ctx.lineTo(centerX, h - margin); // Omega-axis
        ctx.stroke();

        ctx.fillStyle = 'rgba(191, 219, 254, 0.78)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.fillText('θ (rad)', w - margin + 6, centerY - 6);
        ctx.fillText('ω (rad/s)', centerX + 8, margin - 10);

        // Dynamic Axis Ticks
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const tickStep = Math.PI;
        const startAngle = Math.floor((theta_center - thetaRange) / tickStep) * tickStep;
        for (let angle = startAngle; angle < theta_center + thetaRange + tickStep; angle += tickStep) {
            const tickX = centerX + (angle - theta_center) * scaleX;
            if (tickX > margin / 2 && tickX < w - margin / 2) {
                const multiple = Math.round(angle / Math.PI);
                let label = multiple + 'π';
                if (multiple === 0) label = '0';
                if (multiple === 1) label = 'π';
                if (multiple === -1) label = '-π';

                ctx.fillText(label, tickX, centerY + 8);
                ctx.beginPath();
                ctx.moveTo(tickX, centerY - 4);
                ctx.lineTo(tickX, centerY + 4);
                ctx.stroke();
            }
        }

        // BUGFIX 2: Fix trajectory drawing when switching from rotating to oscillating mode.
        if (history.length > 1) {
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.85)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            let first_theta_display = isRotating ? history[0].theta - theta_center : wrapAngle(history[0].theta);
            ctx.moveTo(centerX + first_theta_display * scaleX, centerY - history[0].omega * scaleY);

            for (let i = 1; i < history.length; i++) {
                let current_theta_display = isRotating ? history[i].theta - theta_center : wrapAngle(history[i].theta);
                let prev_theta_display = isRotating ? history[i - 1].theta - theta_center : wrapAngle(history[i - 1].theta);

                // In wrapped mode, if the angle jump is too big, start a new line segment.
                if (!isRotating && Math.abs(current_theta_display - prev_theta_display) > Math.PI) {
                    ctx.moveTo(centerX + current_theta_display * scaleX, centerY - history[i].omega * scaleY);
                } else {
                    ctx.lineTo(centerX + current_theta_display * scaleX, centerY - history[i].omega * scaleY);
                }
            }
            ctx.stroke();
        }

        // Current state point - logic must also use the correct display angle.
        const current_display_theta = isRotating ? state.theta - theta_center : wrapAngle(state.theta);
        const currentX = centerX + current_display_theta * scaleX;
        const currentY = centerY - state.omega * scaleY;
        ctx.fillStyle = 'rgba(167, 139, 250, 0.95)';
        ctx.beginPath();
        ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
        ctx.fill();
    }

    function computeEnergy() {
        const potential = state.m * params.g * params.L * (1 - Math.cos(state.theta));
        const kinetic = 0.5 * state.m * Math.pow(params.L * state.omega, 2);
        return potential + kinetic;
    }

    function updateStats() {
        const energy = computeEnergy();
        const period = 2 * Math.PI * Math.sqrt(params.L / params.g); // Small angle approximation
        
        const format = (val) => val.toFixed(2).padStart(5, ' ');

        statsEl.innerHTML = `
            t = ${format(state.t)} s<br>
            θ = ${format(state.theta)} rad<br>
            ω = ${format(state.omega)} rad/s<br>
            E = ${format(energy)} J<br>
            T ≈ ${format(period)} s
        `.replace(/ /g, '&nbsp;');
    }
    
    // --- Main Loop ---
    function frame(timestamp) {
        if (lastFrameTime === null) lastFrameTime = timestamp;
        const dt = (timestamp - lastFrameTime) / 1000;
        lastFrameTime = timestamp;
        
        if (running) { advance(dt); }
        
        drawPendulum();
        drawPhase();
        updateStats();
        requestAnimationFrame(frame);
    }
    
    // --- Event Listeners ---
    startStopBtn.addEventListener('click', () => {
        running = !running;
        startStopBtn.textContent = running ? 'Pause' : 'Start';
        if (running) lastFrameTime = null;
    });

    resetBtn.addEventListener('click', () => {
        running = false;
        startStopBtn.textContent = 'Start';
        params.theta0 = parseFloat(theta0Slider.value);
        params.omega0 = parseFloat(omega0Slider.value);
        params.L = parseFloat(lengthSlider.value);
        params.g = parseFloat(gravitySlider.value);
        params.b = parseFloat(dampingSlider.value);
        resetState();
    });

    const setupSlider = (slider, valueEl, paramKey, isInitialCondition) => {
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            params[paramKey] = val;
            valueEl.textContent = val.toFixed(2);
            if (isInitialCondition && !running) {
                if (paramKey === 'theta0') params.theta0 = val;
                if (paramKey === 'omega0') params.omega0 = val;
                resetState();
            }
        });
    };
    
    setupSlider(theta0Slider, theta0Value, 'theta0', true);
    setupSlider(omega0Slider, omega0Value, 'omega0', true);
    setupSlider(lengthSlider, lengthValue, 'L', false);
    setupSlider(gravitySlider, gravityValue, 'g', false);
    setupSlider(dampingSlider, dampingValue, 'b', false);

    window.addEventListener('resize', handleResize);
    
    // --- Initialisation ---
    handleResize();
    resetState();
    requestAnimationFrame(frame);
    </script>
</body>
</html>
