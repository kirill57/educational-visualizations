<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pendulum Lab — Driven & Damped</title>
<style>
    :root { --panel: rgba(15, 23, 42, 0.78); }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #1e293b 0%, #0f172a 55%, #020617 100%); color: #f8fafc; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow-x: hidden; }
    .title { margin: 1.2rem 0 0.8rem; text-align: center; padding: 0 1rem; }
    .title h1 { font-size: 2.2rem; font-weight: 800; letter-spacing: -0.03em; margin: 0.3rem 0; text-shadow: 0 8px 20px rgba(59, 130, 246, 0.22); }
    .title p { color: rgba(226, 232, 240, 0.72); margin: 0 auto; max-width: 820px; font-size: 0.95rem; }
    #wrap { position: relative; width: min(1140px, 94vw); border-radius: 0.9rem; border: 1px solid rgba(148, 163, 184, 0.18); box-shadow: 0 18px 40px rgba(15, 23, 42, 0.55); background: rgba(15, 23, 42, 0.4); backdrop-filter: blur(8px); padding: 1.1rem 1.1rem 4.6rem; margin-bottom: 2rem; }
    .layout { display: flex; gap: 1rem; }
    .pane { position: relative; flex: 1; border-radius: 0.75rem; overflow: hidden; border: 1px solid rgba(148, 163, 184, 0.15); background: rgba(15, 23, 42, 0.85); box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.15); }
    canvas { width: 100%; height: 100%; display: block; }
    .pane-label { position: absolute; left: 1rem; top: 0.9rem; padding: 0.25rem 0.75rem; border-radius: 999px; background: rgba(30, 41, 59, 0.75); font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(191, 219, 254, 0.88); backdrop-filter: blur(4px); z-index: 1; }
    #stats { position: absolute; right: 1rem; top: 1rem; background: rgba(15, 23, 42, 0.72); padding: 0.55rem 0.85rem; border-radius: 0.6rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 0.82rem; line-height: 1.6; color: rgba(226, 232, 240, 0.88); border: 1px solid rgba(96, 165, 250, 0.25); z-index: 1;}
    .controls { position: absolute; left: 50%; bottom: 1.2rem; transform: translateX(-50%); display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; justify-content: center; background: transparent; padding: 0.6rem 0.9rem; border-radius: 0.7rem; }
    .controls > * { pointer-events: auto; }
    .btn { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #f1f5f9; padding: 0.4rem 0.9rem; border: 0; border-radius: 0.5rem; font-weight: 600; font-size: 0.82rem; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease; box-shadow: 0 10px 18px rgba(37, 99, 235, 0.28); }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 14px 22px rgba(37, 99, 235, 0.38); }
    .btn:active { transform: translateY(1px); }
    .param-group { display: flex; flex-direction: column; gap: 0.28rem; min-width: 150px; }
    .param-label { font-size: 0.7rem; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; color: rgba(226, 232, 240, 0.75); }
    .range { width: 100%; height: 6px; background: rgba(148, 163, 184, 0.28); border-radius: 3px; outline: none; -webkit-appearance: none; appearance: none; cursor: pointer; }
    .range::-webkit-slider-thumb { width: 16px; height: 16px; border-radius: 50%; background: #38bdf8; border: none; box-shadow: 0 0 10px rgba(56, 189, 248, 0.65); -webkit-appearance: none; }
    .range::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #38bdf8; border: none; box-shadow: 0 0 10px rgba(56, 189, 248, 0.65); }
    select { background: rgba(30,41,59,0.85); color: #e2e8f0; border: 1px solid rgba(148,163,184,0.3); border-radius: 0.5rem; padding: 0.4rem 0.6rem; font-weight: 600; }
    .checkline { display: flex; gap: 0.5rem; align-items: center; font-size: 0.82rem; color: rgba(226,232,240,0.9); }
    .mini { font-size: 0.72rem; color: rgba(226,232,240,0.7); }
    @media (max-width: 940px) {
        #wrap { padding-bottom: 10.5rem; }
        .layout { flex-direction: column; }
        .param-group { min-width: 130px; }
        .controls { width: calc(100% - 2.2rem); }
    }
</style>
</head>
<body>
    <div class="title">
        <h1>Pendulum Lab</h1>
        <p>Adjust the initial angle, angular velocity, length, gravity, damping, and an optional periodic drive. The left panel shows the pendulum’s motion; the right panel shows its phase trajectory and an instantaneous slope field for the chosen drive.</p>
    </div>

    <div id="wrap">
        <div class="layout">
            <div class="pane" id="pendulumPane">
                <canvas id="pendulumCanvas"></canvas>
                <div class="pane-label">Pendulum</div>
                <div id="stats"></div>
            </div>
            <div class="pane" id="phasePane">
                <canvas id="phaseCanvas"></canvas>
                <div class="pane-label">Phase Portrait + Slope Field</div>
            </div>
        </div>

        <div class="controls">
            <button id="startStopBtn" class="btn">Start</button>
            <button id="resetBtn" class="btn">Reset</button>

            <div class="param-group">
                <label class="param-label">Angle θ₀ (rad): <span id="theta0Value">1.50</span></label>
                <input id="theta0Slider" class="range" type="range" min="-3.14" max="3.14" step="0.01" value="1.5" />
            </div>
            <div class="param-group">
                <label class="param-label">Ang. Vel. ω₀ (rad/s): <span id="omega0Value">0.00</span></label>
                <input id="omega0Slider" class="range" type="range" min="-5" max="5" step="0.01" value="0" />
            </div>
            <div class="param-group">
                <label class="param-label">Length L (m): <span id="lengthValue">1.00</span></label>
                <input id="lengthSlider" class="range" type="range" min="0.2" max="2" step="0.01" value="1" />
            </div>
            <div class="param-group">
                <label class="param-label">Gravity g (m/s²): <span id="gravityValue">9.81</span></label>
                <input id="gravitySlider" class="range" type="range" min="1" max="25" step="0.01" value="9.81" />
            </div>
            <div class="param-group">
                <label class="param-label">Damping b: <span id="dampingValue">0.00</span></label>
                <input id="dampingSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" />
            </div>

            <!-- New: Driving controls -->
            <div class="param-group">
                <label class="param-label">Drive</label>
                <select id="driveSelect">
                    <option value="none" selected>None</option>
                    <option value="sine">Sine</option>
                    <option value="square">Square</option>
                    <option value="triangle">Triangle</option>
                    <option value="saw">Sawtooth</option>
                </select>
                <div class="mini">Forcing enters as +A·f(t)</div>
            </div>
            <div class="param-group">
                <label class="param-label">Amplitude A (rad/s²): <span id="driveAmpValue">0.00</span></label>
                <input id="driveAmpSlider" class="range" type="range" min="0" max="15" step="0.01" value="0" />
            </div>
            <div class="param-group">
                <label class="param-label">Frequency Ω (rad/s): <span id="driveFreqValue">3.00</span></label>
                <input id="driveFreqSlider" class="range" type="range" min="0" max="15" step="0.01" value="3" />
            </div>

            <!-- New: Slope field controls -->
            <div class="param-group">
                <label class="param-label">Slope Field</label>
                <label class="checkline"><input type="checkbox" id="showFieldToggle" checked> Show slope field</label>
                <label class="checkline"><input type="checkbox" id="followTimeToggle" checked> Field follows time</label>
                <label class="param-label">Field phase φ (rad): <span id="fieldPhaseValue">0.00</span></label>
                <input id="fieldPhaseSlider" class="range" type="range" min="0" max="6.28318" step="0.01" value="0" />
                <div class="mini">If not following time, snapshot at t = φ/Ω</div>
            </div>
        </div>
    </div>

<script>
/* ---------- Elements ---------- */
const $ = id => document.getElementById(id);
const pendulumCanvas = $('pendulumCanvas');
const phaseCanvas    = $('phaseCanvas');
const pendulumCtx    = pendulumCanvas.getContext('2d');
const phaseCtx       = phaseCanvas.getContext('2d');

const startStopBtn   = $('startStopBtn');
const resetBtn       = $('resetBtn');

const theta0Slider   = $('theta0Slider');
const omega0Slider   = $('omega0Slider');
const lengthSlider   = $('lengthSlider');
const gravitySlider  = $('gravitySlider');
const dampingSlider  = $('dampingSlider');

const theta0Value    = $('theta0Value');
const omega0Value    = $('omega0Value');
const lengthValue    = $('lengthValue');
const gravityValue   = $('gravityValue');
const dampingValue   = $('dampingValue');

const driveSelect    = $('driveSelect');
const driveAmpSlider = $('driveAmpSlider');
const driveAmpValue  = $('driveAmpValue');
const driveFreqSlider= $('driveFreqSlider');
const driveFreqValue = $('driveFreqValue');

const showFieldToggle= $('showFieldToggle');
const followTimeToggle=$('followTimeToggle');
const fieldPhaseSlider=$('fieldPhaseSlider');
const fieldPhaseValue=$('fieldPhaseValue');

const statsEl        = $('stats');

/* ---------- Global State ---------- */
const TWO_PI = 2 * Math.PI;

const params = {
  L: parseFloat(lengthSlider.value),
  g: parseFloat(gravitySlider.value),
  theta0: parseFloat(theta0Slider.value),
  omega0: parseFloat(omega0Slider.value),
  b: parseFloat(dampingSlider.value),

  // driving
  driveType: driveSelect.value,   // 'none'|'sine'|'square'|'triangle'|'saw'
  A: parseFloat(driveAmpSlider.value),   // rad/s^2
  Omega: parseFloat(driveFreqSlider.value), // rad/s

  // slope field options
  showField: showFieldToggle.checked,
  followFieldTime: followTimeToggle.checked,
  fieldPhase: parseFloat(fieldPhaseSlider.value), // rad snapshot
};

const state = { theta: params.theta0, omega: params.omega0, t: 0, m: 1 };

let running = false;
let lastFrameTime = null;
let accumulator = 0;
const baseStep = 0.004;
const history = [];
let lastSampleTime = 0;
const sampleInterval = 0.01;
const maxHistory = 2200;

/* ---------- Canvas / Resize ---------- */
function handleResize() {
  const wrapBounds = $('wrap').getBoundingClientRect();
  const padding = 1.1 * parseFloat(getComputedStyle(document.documentElement).fontSize);
  const contentWidth = wrapBounds.width - (padding * 2);
  const isColumnLayout = window.innerWidth < 940;

  let pendulumW, pendulumH, phaseW, phaseH;
  if (isColumnLayout) {
    pendulumW = phaseW = contentWidth;
    pendulumH = phaseH = contentWidth * 0.8;
  } else {
    pendulumW = contentWidth * 0.5 - 5;
    phaseW    = contentWidth * 0.5 - 5;
    pendulumH = phaseH = contentWidth * 0.45;
  }

  const setupOne = (canvas, ctx, w, h) => {
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    canvas.width  = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0); // reset first (bugfix)
    ctx.scale(dpr, dpr);
  };

  setupOne(pendulumCanvas, pendulumCtx, pendulumW, pendulumH);
  setupOne(phaseCanvas,    phaseCtx,    phaseW,    phaseH);
}

/* ---------- Driving waveforms ---------- */
function periodicUnit(type, x /* = Ω t */) {
  switch (type) {
    case 'sine':     return Math.sin(x);
    case 'square':   return Math.sign(Math.sin(x));                 // -1,0,+1
    case 'triangle': return (2/Math.PI) * Math.asin(Math.sin(x));   // [-1,1]
    case 'saw': {
      const r = x % TWO_PI;
      return (r / Math.PI) - 1;                                     // [-1,1] ramp
    }
    default: return 0;
  }
}
function driveAccel(t) {
  if (params.driveType === 'none' || params.A === 0 || params.Omega === 0) return 0;
  return params.A * periodicUnit(params.driveType, params.Omega * t);
}

/* ---------- RK4 (non-autonomous) ---------- */
function rk4Step(dt) {
  const y = { theta: state.theta, omega: state.omega };
  const gL = params.g / params.L;

  const f = (y_in, t_in) => ({
    d_theta: y_in.omega,
    d_omega: -gL * Math.sin(y_in.theta) - params.b * y_in.omega + driveAccel(t_in)
  });

  const t = state.t;

  const k1 = f(y, t);
  const k2 = f({ theta: y.theta + 0.5 * dt * k1.d_theta, omega: y.omega + 0.5 * dt * k1.d_omega }, t + 0.5*dt);
  const k3 = f({ theta: y.theta + 0.5 * dt * k2.d_theta, omega: y.omega + 0.5 * dt * k2.d_omega }, t + 0.5*dt);
  const k4 = f({ theta: y.theta + dt * k3.d_theta,       omega: y.omega + dt * k3.d_omega       }, t + dt);

  state.theta += dt/6 * (k1.d_theta + 2*k2.d_theta + 2*k3.d_theta + k4.d_theta);
  state.omega += dt/6 * (k1.d_omega + 2*k2.d_omega + 2*k3.d_omega + k4.d_omega);
  state.t     += dt;
}

function advance(frameDt) {
  const clampedDt = Math.min(frameDt, 0.06);
  accumulator += clampedDt;
  while (accumulator >= baseStep) {
    rk4Step(baseStep);
    recordHistory();
    accumulator -= baseStep;
  }
}

/* ---------- History ---------- */
function recordHistory() {
  if (state.t - lastSampleTime < sampleInterval) return;
  lastSampleTime = state.t;
  history.push({ theta: state.theta, omega: state.omega });
  if (history.length > maxHistory) history.splice(0, history.length - maxHistory);
}
function resetHistory() { history.length = 0; lastSampleTime = 0; }
function resetState() {
  state.theta = params.theta0;
  state.omega = params.omega0;
  state.t = 0;
  accumulator = 0;
  resetHistory();
  recordHistory();
}

/* ---------- Drawing: Pendulum ---------- */
function drawPendulum() {
  const ctx = pendulumCtx;
  const w = pendulumCanvas.clientWidth;
  const h = pendulumCanvas.clientHeight;
  ctx.clearRect(0, 0, w, h);

  const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
  bgGradient.addColorStop(0, 'rgba(15, 23, 42, 0.95)');
  bgGradient.addColorStop(1, 'rgba(2, 6, 23, 0.95)');
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, w, h);

  const pivotX = w / 2;
  const pivotY = h * 0.2;
  const pixelsPerMeter = Math.min(w * 0.4, h * 0.7) / params.L;
  const bobRadius = 18;

  const bobX = pivotX + pixelsPerMeter * params.L * Math.sin(state.theta);
  const bobY = pivotY + pixelsPerMeter * params.L * Math.cos(state.theta);

  // Ceiling
  ctx.fillStyle = '#1e293b';
  ctx.fillRect(0, pivotY - 15, w, 15);
  ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
  ctx.beginPath(); ctx.moveTo(0, pivotY); ctx.lineTo(w, pivotY); ctx.stroke();

  // Rod
  ctx.strokeStyle = 'rgba(148, 163, 184, 0.8)';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(pivotX, pivotY); ctx.lineTo(bobX, bobY); ctx.stroke();

  // Pivot
  ctx.fillStyle = '#94a3b8';
  ctx.beginPath(); ctx.arc(pivotX, pivotY, 6, 0, Math.PI * 2); ctx.fill();

  // Bob
  const bobGradient = ctx.createRadialGradient(bobX - 5, bobY - 5, 2, bobX, bobY, bobRadius);
  bobGradient.addColorStop(0, '#f1f5f9');
  bobGradient.addColorStop(1, '#94a3b8');
  ctx.fillStyle = bobGradient;
  ctx.beginPath(); ctx.arc(bobX, bobY, bobRadius, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = 'rgba(15, 23, 42, 0.6)';
  ctx.lineWidth = 2; ctx.stroke();
}

/* ---------- Drawing: Phase + Slope Field ---------- */
function drawPhase() {
  const ctx = phaseCtx;
  const w = phaseCanvas.clientWidth;
  const h = phaseCanvas.clientHeight;
  ctx.clearRect(0, 0, w, h);

  ctx.fillStyle = 'rgba(2, 6, 23, 0.96)';
  ctx.fillRect(0, 0, w, h);

  const margin = 36;
  const centerX = w / 2;
  const centerY = h / 2;

  const E_critical = 2 * state.m * params.g * params.L;
  const current_E  = computeEnergy();
  const isRotating = current_E > E_critical && Math.abs(state.omega) > 0.1;
  const theta_center = isRotating ? state.theta : 0;
  const wrapAngle = angle => ((angle + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI;

  // Dynamic omega range for visibility
  let maxAbsOmega = 0;
  if (history.length > 0) {
    for (let i=0;i<history.length;i++) maxAbsOmega = Math.max(maxAbsOmega, Math.abs(history[i].omega));
  }
  maxAbsOmega = Math.max(maxAbsOmega, Math.abs(state.omega), 2);
  const omegaRange = Math.max(4, maxAbsOmega * 1.25);

  const thetaRange = Math.PI;
  const scaleX = (w / 2 - margin) / thetaRange;
  const scaleY = (h / 2 - margin) / omegaRange;

  // Axes
  ctx.strokeStyle = 'rgba(96, 165, 250, 0.75)';
  ctx.lineWidth = 1.4;
  ctx.beginPath();
  ctx.moveTo(margin, centerY); ctx.lineTo(w - margin, centerY); // theta-axis
  ctx.moveTo(centerX, margin); ctx.lineTo(centerX, h - margin); // omega-axis
  ctx.stroke();

  ctx.fillStyle = 'rgba(191, 219, 254, 0.78)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
  ctx.fillText('θ (rad)', w - margin + 6, centerY - 6);
  ctx.fillText('ω (rad/s)', centerX + 8, margin - 10);

  // Theta ticks at multiples of π
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  const tickStep = Math.PI;
  const startAngle = Math.floor((theta_center - thetaRange) / tickStep) * tickStep;
  for (let angle = startAngle; angle < theta_center + thetaRange + tickStep; angle += tickStep) {
    const tickX = centerX + (angle - theta_center) * scaleX;
    if (tickX > margin / 2 && tickX < w - margin / 2) {
      const multiple = Math.round(angle / Math.PI);
      let label = multiple + 'π';
      if (multiple === 0) label = '0';
      if (multiple === 1) label = 'π';
      if (multiple === -1) label = '-π';
      ctx.fillText(label, tickX, centerY + 8);
      ctx.beginPath();
      ctx.moveTo(tickX, centerY - 4);
      ctx.lineTo(tickX, centerY + 4);
      ctx.stroke();
    }
  }

  // ---- NEW: Slope field (instantaneous) ----
  if (params.showField) {
    // Decide which time to snapshot at
    let t_field = state.t;
    if (!params.followFieldTime) {
      // t = φ/Ω (if Ω=0, use 0)
      t_field = (params.Omega > 0) ? (params.fieldPhase / params.Omega) : 0;
    }
    drawSlopeField(ctx, {
      w, h, centerX, centerY, theta_center, scaleX, scaleY,
      thetaRange, omegaRange, t_field
    });
  }

  // Trajectory
  if (history.length > 1) {
    ctx.strokeStyle = 'rgba(56, 189, 248, 0.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();

    let first_theta_display = isRotating ? history[0].theta - theta_center : wrapAngle(history[0].theta);
    ctx.moveTo(centerX + first_theta_display * scaleX, centerY - history[0].omega * scaleY);

    for (let i = 1; i < history.length; i++) {
      let current_theta_display = isRotating ? history[i].theta - theta_center : wrapAngle(history[i].theta);
      let prev_theta_display    = isRotating ? history[i-1].theta - theta_center : wrapAngle(history[i-1].theta);
      if (!isRotating && Math.abs(current_theta_display - prev_theta_display) > Math.PI) {
        ctx.moveTo(centerX + current_theta_display * scaleX, centerY - history[i].omega * scaleY);
      } else {
        ctx.lineTo(centerX + current_theta_display * scaleX, centerY - history[i].omega * scaleY);
      }
    }
    ctx.stroke();
  }

  // Current state
  const current_display_theta = isRotating ? state.theta - theta_center : wrapAngle(state.theta);
  const currentX = centerX + current_display_theta * scaleX;
  const currentY = centerY - state.omega * scaleY;
  ctx.fillStyle = 'rgba(167, 139, 250, 0.95)';
  ctx.beginPath(); ctx.arc(currentX, currentY, 6, 0, Math.PI * 2); ctx.fill();
}

function drawSlopeField(ctx, geom) {
  const { w, h, centerX, centerY, theta_center, scaleX, scaleY, thetaRange, omegaRange, t_field } = geom;

  // Grid resolution
  const cols = 23, rows = 17;
  const dTheta = (2*thetaRange) / (cols - 1);
  const dOmega = (2*omegaRange) / (rows - 1);

  ctx.lineWidth = 1.2;
  ctx.strokeStyle = 'rgba(148, 163, 184, 0.5)';

  const gL = params.g / params.L;

  for (let i = 0; i < cols; i++) {
    const theta = (theta_center - thetaRange) + i * dTheta; // world theta
    const x = centerX + (theta - theta_center) * scaleX;

    for (let j = 0; j < rows; j++) {
      const omega = (-omegaRange) + j * dOmega; // world omega
      const y = centerY - omega * scaleY;

      // Vector field (θ', ω') at (θ, ω) for snapshot time
      const dtheta = omega;
      const domega = -gL * Math.sin(theta) - params.b * omega + driveAccel(t_field);

      // Convert to pixel vector and normalize
      let vx = dtheta * scaleX;
      let vy = -domega * scaleY;
      const mag = Math.hypot(vx, vy);
      if (mag < 1e-9) continue;

      vx /= mag; vy /= mag;
      const len = 16; // pixels
      const x2 = x + vx * len, y2 = y + vy * len;

      ctx.beginPath();
      ctx.moveTo(x - vx * len * 0.5, y - vy * len * 0.5); // center the segment
      ctx.lineTo(x2 - vx * len * 0.5, y2 - vy * len * 0.5);
      ctx.stroke();
    }
  }
}

/* ---------- Energy & Stats ---------- */
function computeEnergy() {
  const potential = state.m * params.g * params.L * (1 - Math.cos(state.theta));
  const kinetic   = 0.5 * state.m * Math.pow(params.L * state.omega, 2);
  return potential + kinetic;
}
function updateStats() {
  const energy = computeEnergy();
  const omega0 = Math.sqrt(params.g / params.L); // small-angle natural freq
  const period = 2 * Math.PI / omega0;           // small-angle period

  const format = (val, n=2) => Number(val).toFixed(n).padStart(6, ' ');
  statsEl.innerHTML = `
    t = ${format(state.t)} s<br>
    θ = ${format(state.theta)} rad<br>
    ω = ${format(state.omega)} rad/s<br>
    E = ${format(energy)} J<br>
    ω₀ ≈ ${format(omega0)} rad/s,  T₀ ≈ ${format(period)} s<br>
    A = ${format(params.A)} rad/s²,  Ω = ${format(params.Omega)} rad/s
  `.replace(/ /g, '&nbsp;');
}

/* ---------- Main Loop ---------- */
function frame(timestamp) {
  if (lastFrameTime === null) lastFrameTime = timestamp;
  const dt = (timestamp - lastFrameTime) / 1000;
  lastFrameTime = timestamp;

  if (running) advance(dt);

  drawPendulum();
  drawPhase();
  updateStats();
  requestAnimationFrame(frame);
}

/* ---------- UI wiring ---------- */
startStopBtn.addEventListener('click', () => {
  running = !running;
  startStopBtn.textContent = running ? 'Pause' : 'Start';
  if (running) lastFrameTime = null;
});

resetBtn.addEventListener('click', () => {
  running = false;
  startStopBtn.textContent = 'Start';
  params.theta0 = parseFloat(theta0Slider.value);
  params.omega0 = parseFloat(omega0Slider.value);
  params.L      = parseFloat(lengthSlider.value);
  params.g      = parseFloat(gravitySlider.value);
  params.b      = parseFloat(dampingSlider.value);
  params.A      = parseFloat(driveAmpSlider.value);
  params.Omega  = parseFloat(driveFreqSlider.value);
  params.driveType = driveSelect.value;
  resetState();
});

function setupSlider(slider, valueEl, paramKey, isInitialCondition) {
  slider.addEventListener('input', (e) => {
    const val = parseFloat(e.target.value);
    params[paramKey] = val;
    valueEl.textContent = val.toFixed(2);
    if (isInitialCondition && !running) resetState();
  });
}

setupSlider(theta0Slider, theta0Value, 'theta0', true);
setupSlider(omega0Slider, omega0Value, 'omega0', true);
setupSlider(lengthSlider, lengthValue, 'L', false);
setupSlider(gravitySlider, gravityValue, 'g', false);
setupSlider(dampingSlider, dampingValue, 'b', false);
setupSlider(driveAmpSlider, driveAmpValue, 'A', false);
setupSlider(driveFreqSlider, driveFreqValue, 'Omega', false);
setupSlider(fieldPhaseSlider, fieldPhaseValue, 'fieldPhase', false);

driveSelect.addEventListener('change', () => { params.driveType = driveSelect.value; });
showFieldToggle.addEventListener('change', () => { params.showField = showFieldToggle.checked; });
followTimeToggle.addEventListener('change', () => {
  params.followFieldTime = followTimeToggle.checked;
  fieldPhaseSlider.disabled = params.followFieldTime;
});

window.addEventListener('resize', handleResize);

/* ---------- Init ---------- */
handleResize();
fieldPhaseSlider.disabled = params.followFieldTime; // initial UI state
resetState();
requestAnimationFrame(frame);
</script>
</body>
</html>
